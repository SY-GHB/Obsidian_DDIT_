#### 6-5 인스턴스 멤버와 정적 멤버
클래스에 선언된 필드와 메소드가 모두 객체 내부에 포함되는 것은 아니다. 이를 알아보자.

클래스는 설계도라고 했다.
같은 설계도로 만들어진 객체(인스턴스)들은 클래스 멤버(필드, 메소드)를 가지고 있을 텐데,
만약 모든 객체의 필드값이 전부 다르다면 객체마다 필드값을 정해주게 될 테다.
그런데 모든 객체의 필드값이 전부 같다면 이 필드를 모든 객체마다 가지고 있어야 할 필요가 있을까? 메모리 낭비다.

이런, 상황에 따라 한곳에 두고 공유하거나 각자 가져가거나 중 상황에 맞게 선언할 수 있도록 인스턴스 멤버와 정적 멤버를 구별한다.

인스턴스 멤버: 객체마다 가지고 있는 멤버
정적 멤버: 클래스에 위치시키고 객체들이 공유하는 멤버.

##### 1. 인스턴스 멤버와 this
인스턴스 멤버란 클래스 외부에서 사용할 때  <u>객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드</u>를 말하는데,  이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.
인스턴스 필드와 인스턴스 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.

###### 1) 인스턴스 멤버 선언
인스턴스 필드는 객체마다 따로 존재하고, <u>인스턴스 메소드는 메소드 영역에 저장되고 공유</u>된다.

```
public class Car {
	// 인스턴스 필드를 선언했다.
	int gas;
	// 인스턴스 메소드를 선언했다. - 메소드 영역에 저장되고 공유된다.
	void setSpeed(int speed) {...}
}
```
gas 필드와 setSpeed() 메소드는 인스턴스 멤버이기 때문에, 외부 클래스에서 사용하기 위해서는
우선 Car 객체(인스턴스)를 생성하고 참조변수를 통해 접근해야 한다.
```
// 객체를 생성해주었다.
Car myCar = new Car();

// myCar이라는 참조변수를 통해 인스턴스 필드에 접근했다.
myCar.gas = 10;
// myCar이라는 참조변수를 통해 인스턴스 메소드에 접근했다
myCar.setSpeed(60);
```


그런데 인스턴스 메소드는 객체에 소속된 멤버인데, 왜 객체 내부가 아닌 메소드 영역에 저장되고 공유되는가?
	메소드는 코드 블록이므로 객체마다 동일한 코드 블록을 가지고 있을 필요가 없기 때문이다.

근데 왜 인스턴스라고 불러?
	메모리 블록 내부에 인스턴스 필드 등이 사용되는 경우가 있기 때문,
	인스턴스 필드가 사용되면 메소드 역시 객체 없이 실행될 수 없다.

뭔소리야? 나의 선현 여름이가 어떻게든 설명을 해 준 이미지를 첨부한다.
	![[Pasted image 20231116212645.png]]
	
	 역시 무슨말인지 잘 모르겠다. ㅎㅎ
	
	![[Pasted image 20231116212819.png]]
	모르겠다. 그냥 인스턴스 메서드는 메소드 영역에 저장된다를 외우자.
###### 2) this
객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하듯,
객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.

this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우,
인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

```
//생성자의 매개변수 타입이 String에 이름이 model이다.
Car(String model){
	this.model = model;
}

//메소드의 매개변수 타입과 이름도 String에 model이네?
void setModel(String model){
	// 그렇다면 this를 써서 이 moedel은 인스턴스 멤버인 model임을 명시해주자.
	this.model = model;
}

```


##### 2. 정적 멤버와 static
정적 멤버는 클래스에 고정된 멤버로서 <u>객체를 생성하지 않고 사용할 수 있는 필드와 메소드</u>를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다.
static메소드에서 다른 메소드를 호출하려면 호출되는 메소드도 static이어야 한다. (인스턴스 메소드일 경우 객체를 생성하고 불러주면 된다.)
###### 1) 정적 멤버 선언
정적 필드와 정적 메소드를 선언하려면 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다.
```
public class 클래스{
	//정적 필드
	static 타입 필드[=초기값];
	
	//정적 메소드
	staic 리턴타입 메소드이름 (매개변수){
	}
}
```

-  필드를 선언할 때 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로, 객체마다 따로 가지고 있을 필요가 없는 공용 데이터라면 정적 필드로 선언하는 것이 좋다.
	예를 들어, 계산기 클래스에서 π(파이)값은  정적 필드로 선언하겠지만
	계산기 색깔은 인스턴스 필드로 선언해야 계산기마다 색이 달라지겠다.

-  메소드의 경우 인스턴스 필드를 포함하고 있다면 인스턴스 메소드로, 인스턴스 필드를 포함하고 있지 않다면 정적 메소드로 선언한다.
	계산기 클래스의 덧셈, 뺄셈 기능은 외부에서 주어지는 매개값들(밖에서 준다- 내(인스턴스) 필드가 아니다.)로 수행하므로 정적 메소드로 선언하는 것이 좋다.
	그러나 계산기 별 색은 인스턴스 필드로 선언되었으므로, 계산기 색을 변경하는 메소드는 인스턴스 메소드가 되겠다.

###### 2) 정적 멤버 사용
클래스 이름과 함께 도트 연산자로 접근하여 사용한다.
```
클래스.필드
클래스.메소드(매개값, ...);
```

예를 들어 Calculator 클래스가 다음과 같이 작성되었다면,
```
public class Calculater{
	static doulbe pi = 3.14159;
	static int plus(int x, int y) {...}
	static int minus(int x, int y) {...}
}
```
정적 필드 pi와 정적 메소드 plus(), minus()는 다음과 같이 사용할 수 있다.
```
double result = 10*10*Calculator.pi
int result2 = Calculator.plus(10, 5);
int result3 = Calculator.minus(10, 5);
```
원칙적으로는 클래스 이름으로 접근해야 하지만, 다음처럼 객체 참조 변수로도 접근이 가능하다.
```
Calculator myCalcu = new Calculator();
double result = 10*10*Calculator.pi
int result2 = myCalcu.plus(10, 5);
int result3 = myCalcu.minus(10, 5);

```
그렇지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다.

###### 3) 정적 메소드 선언 시 주의할 점
객체가 없어도 실행되기 때문에,
<u>정적 메소드를 선언할 때에는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.</u>
또한, 객체 차신의 참조인 <u>this 키워드도 사용이 불가능</u>하다.

정적 메소드에서 인스턴스 멤버를 사용하고 싶다면,
<u>객체를 먼저 생성하고 참조변수로 접근해야 한다.</u>
```
static void method3(){
	//객체를 생성하고
	ClassName obj = new ClassName();
	// 참조변수 obj로 객체에 접근해 필드를 만들었다.
	obj.field1 = 10;
	// 역시 참조변수 obj로 객체에 접근해 메소드를 만들어주었다.
	obj.method1();
}
```

main()메소드에도 동일한 규칙이 적용된다.
main()메소드도 정적 메소드이므로, 객체 생성 없이는 인스턴스 필드와 인스턴스 메소드를 바로 사용할 수 없다.  

또 이게 뭔소리야? 싶은 부분을 선현 여름이에게 물어봤었다. 이하 카톡 캡쳐.
	![[Pasted image 20231117205444.png]]
	![[Pasted image 20231117205646.png]]

##### 3. 싱글톤
어떤 경우, 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 이럴 때 만드는 것을 싱글톤이라 한다.
	단 하나만 생성되는 객체라는 의미에서 Singleton이다.

하나만 만들도록 하는 이유는?
	1. DB접근을 최소화하기 위함이다. DB에는 접속자 수 제한이 있는데, 접근할 때마다 객체가 생성된다고 치면 나 혼자 DB접속을 여러 개 차지할 수도 있다.
	2. 객체를 로딩할 때, 엄청나게 큰 연산작업을 하는or큰 파일을 읽어들이는 객체를 생성한다고 치면 생성할 때 오래 걸리게 된다. 싱글톤을 적용하지 않으면 객체 생성마다 그 오랜 시간을 기다려야 하는데, 싱글톤을 쓰면 금방금방 만들 수 있다.

###### 싱글톤을 만들려면,
1. 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 <u>생성자의 앞에 private 접근 제한자</u>를 붙여주면 된다.
	왜? 생성자가 뭐였지?
	'클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당'한다 고 내가 써 뒀다.
	생성자를 호출한 만큼 객체가 생성되니까 호출을 못 하게 막아야지!
	그러나 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.  외부호출만 막았으니까.

2. 그리고 자신의 타입인 정적 필드를 하나 선언하고, 자신의 객체를 생성해 초기화한다. 
이 정적 필드에도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다.

3. 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고, 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.
```
public class 클래스{
	// 2. 정적 필드 선언
	private static 클래스 singleton = new 클래스();
	
	// 1. 생성자 앞에 접근제한자 붙이기.
	private 클래스() {}
	
	// 3. 정적메소드 getInstance 선언, 자신의 객체 리턴하기.
	static 클래스 getInstance() {
		return singleton;
	}
}
```
``싱클톤 선언방법은 열다섯가지정도 된다고 한다. 다른 방식으로도 얼마든지 선언이 가능하다는 얘기다.``


이제 외부에서 객체를 얻는 방법은 getInstance() 메소드를 호출하는 방법 하나밖에 없다.
getInstance()메소드는 단 하나의 객체만 리턴한다.
```
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```
여기서의 변수1과 변수2는 동일한 객체를 참조하는 것이다.

##### 4. final필드와 상수
###### final 필드
저장된 초기값이 최종적인 값이 되어 프로그램 실행 도중에 수정할 수 없는 필드를 final필드라 한다.
```
final 타입 필드 [=초기값];
```
의 형태로 선언한다.

final필드의 초기값을 줄 수 있는 방법은 딱 두가지이다.
1. 필드 선언시에 초기값을 준다.
	 단순 값의 경우 1번이 제일 간단하다.
2.  생성자에서 초기값을 준다.
	복잡한 초기화 코드가 필요하거나 객체 생성 시 외부 데이터로 초기화해야한다면 생성자에서 초기화값을 지정하는 것이 좋다.
	생성자는 final필드의 최종 초기화를 마쳐야 하는데, 초기화되지 않은 final 필드가 있다면 컴파일 에러가 발생한다.

###### 상수(constanst)
일반적으로 원주율이나 지구의 둘레, 무게 등 불변의 값을 상수, static final이라 부른다.
자바에서는 이런 불변의 값을 저장하는 필드를  상수 constanst 라고 한다.
상수 이름은 모두 대문자로 작성하는 것이 관례로, 여러 단어가 혼합됐다면 언더바로 연결한다.

-  상수 필드의 선언 예시
```
static final Double PI = 3.14159;
static final Double EARTH_RADIOUS = 6400;
static final Double EARTH_AREA = 4 * MATH.PI * EARTH_RADIOUS * EARTH_RADIOUS;
```

그럼 final필드도 한 번 초기화되면 바뀔 수 없으니 상수라고 불러도 되지 않나?
	아니다.
	불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠며(static이며 final이다: 클래스에만 존재하며 객체마다 존재하지는 않는다.), 여러 값으로 초기화되지 않는 반면 final필드는 생성자의 매개값을 통해 여러가지 값을 받을 수 있으므로 상수가 될 수 없다.

static: 어느 곳에서나 가져갈 수 있다. static이 없으면 그 클래스에서만 쓸 수 있다.

#### SOLID - S. 단일책임의 원칙
객체지향 설계의 5가지 원칙 SOLID란게 있다. 찾아보니까,
	**S**RP(Single Responsibility Principle): 단일 책임 원칙
	**O**CP(Open Closed Priciple): 개방 폐쇄 원칙
	**L**SP(Listov Substitution Priciple): 리스코프 치환 원칙
	**I**SP(Interface Segregation Principle): 인터페이스 분리 원칙
	**D**IP(Dependency Inversion Principle): 의존 역전 원칙

이라고 나오는데, 나머지는 차차 케이스가 나오면 알아보도록 하자.

오늘 배운 건 단일 책임의 원칙이라고, 한 메소드에는 되도록 하나의 기능을 구현하라는 의미다.
메소드에 여러 기능이 결합되어 있으면, 그 메소드는 재사용 가능성이 현저히 떨어진다.

외에도 다른 문제가 있을 수 있는데, 수업시간에 진행한 아래의 예시를 보자.
배열의 각 원소를 2배로 만들어 총합을 구하는 메소드를 만들어보았다.

```
package kr.or.ddit.study06.sec04.test04;

import java.util.Arrays;

public class MethodCopy {
	public static void main(String[] args) {
		MethodCopy mc = new MethodCopy();
		int[] arr = { 1, 2, 3 };
		// 배열 원본을 2배로 증가시킨 후 총합*2
		/*
		 * 2배로 증가시키는 건 다른 메소드에서 했는데
		 * 2배한 값이 여기서 출력되네?
		 * 
		 * 얕은 복사-원본 데이터와 같은 메모리 주소 공유,
		 * 원본데이터에도 영향을 주기 때문에 여기서도 출력된다.
		 * 값이 어디서 바뀌었는지 확인이 어려움!!!!
		 * 
		 */
	//		int sum = mc.sumMultiple2(arr);
	//		System.out.println(sum);
	//		System.out.println(Arrays.toString(arr));
		arr = mc.copy2(arr);
		
		
	}
	
	// 그래서 원본데이터를 2배로 만드는 로직을 명시적으로 빼내줘야 한다.
	// 웬만하면 원본데이터를 건드리지말고 2배가 된 데이터를 리턴을 받는 것이 좋다.
	public int[] copy2(int[] arr) {
		/*
		 * 2배로 증가시키기
		 */
		
		int sum=0;
		for (int i = 0; i < arr.length; i++) {
			arr[i] *= 2;
		}
		return arr;
	}
	
	
	// 단순히 총합을 구하고 싶은데 얕은복사로 원본데이터에 손상을 주게 된다면?
	// 총합도 구하고 2배도 구하고 싶다고 이걸 동시에 실행시키는 메소드를 만들면
	// 나중에 총합만 구하고 싶을 때 2배로 만드는 로직을 못 찾는다.
	// 주석도 달아주자.
	public int sumMultiple2(int[] arr) {
		/*
		 * 2배로 증가시키기
		 */
		
		int sum=0;
		for (int i = 0; i < arr.length; i++) {
			arr[i] *= 2;
			sum += arr[i];
		}
		return sum;
	}
```
그런데 배열의 원소를 2배로 만드는 로직과 총합을 구하는 로직을 합쳐버리면 나중에 그 배열을 데이터로 삼아 다른 기능을 하는 메소드를 작동시킬 때, 원본의 배열값이 2배가 된 상태로 남아있으면 원본데이터가 왜곡된 것이므로 원하는 결과를 얻을 수 없을 것이다. 그러면 그 2배로 만들어주는 메소드를 찾아서 수정해주던지 해야 할텐데, 총합을 구하는 로직과 얽혀 있으면 2배로 만드는 로직이 어디에 있는지 찾기도 어려워질뿐더러 그 메소드를 제외시키면 총합을 구하는 로직은 또 새로 구현해야 하는 것이다.

그러니까 기억하자, 한 메소드에는 하나의 기능, 단일책임의 원칙.