아 패키지나 클래스명 바꾸는거 F2더라!!!

##### 기본타입과 참조타입
데이터 타입은 기본타입과 참조타입으로 나뉜다.
- 기본 타입: 정수, 실수, 문자, 논리 리터럴 저장, 변수에 값 자체를 저장.
- 참조 타입: 객체의 번지를 참조하는 타입. 배열, 열거, 클래스, 인터페이스. 변수에 객체의 번지 저장

기본타입 변수에 값을 저장한다는 것은 메모리에 (타입 크기에 따른)공간을 할당한다는 의미로,
변수 여러개를 설정하면 메모리 사용량이 늘어난다.

참조 타입 변수에 값을 저장한다는 건 메모리에 공간을 할당하는 게 아니라 힙 영역에 저장된다는 의미로, 변수 이름이 달라져도 같은 힙 영역에 잇는 같은 값이면 할당된 메모리는 늘어나지 않는다.
참조타입 변수는 객체를 참조하지 않는다는 뜻으로 null값을 가질 수 있다.
null로 초기화된 참조변수도 스택 영역에 생성된다.

```
private void method1() {
		String str1 = "홍길동";
		String str2 = "홍길동";
		String str3 = "강감찬";
		String str4 = new String("홍길동");
		
		System.out.println(str1 == str2); // 이미 str1에 할당한 값을 꺼내쓰므로 true
		System.out.println(str2 == str3); 
		System.out.println(str1 == str4); // new는 새로운 객체 생성이므로 false
		System.out.println(str1.equals(str4)); // String은 변수.equals(변수)로 비교하라.
	}
```



비교 연산자 (= =, !=) 가 기본타입에서는 값을 비교하지만 참조 타입에서는 번지를 비교하므로,
<u>문자열 비교를 위해서는 equals를 사용</u>하여야 한다. 
new를 볼때마다 객체가 새로 생겼다라고 생각하면 된다.
new 연산자:  객체 생성 연산자, 힙 영역에 새로운 객체 생성.
우리가 클래스명 obj = new 클래스명(); 으로 메소드만들때도 객체가 새로 만들어지고 있었던 것.

메모리 사용 영역
- 메소드 영역
- 힙 영역
- JVM 스택 영역: 메소드를 호출할 때마다 프레임이 추가되고, 메소드가 종료되면 해당 프레임이 제거됨.(메소드 안에서 선언한 것을 밖에서 못쓴다.)

static을 사용한 변수는 메모리영역에 한번 올라가기때문에 객체를 생성하지 않아도 사용할 수 있다.
obj.method1(); private void  < 객체를 생성하는 방법
method1(); private static void < 객체가 없지만 static으로 메모리 영역에 올려줌

참조를 잃은 String 객체는 쓰레기 수집기(Garbage Collector)통해 메모리에서 자동 제거.
자바에서는 자동제거지만 c언어에서는 직접 삭제해줘야 한다.


##### 배열 만들기
###### 배열을 선언하는 형식
1. 기본 형식

> ==변수타입[ ] 배열명 = new 변수타입[숫자];==

여기서의 변수 타입은 배열의 원소가 가지는 타입을 지정하고,
숫자는 배열의 원소 갯수를 얘기한다.
원소가 가질 수 있는 인덱스(배열의 항목에 붙인 번호.)는 숫자-1번까지 존재한다.
그래서 배열 속 원소를 모두 세기 위해 반복 횟수를 정해준다면
언제나 배열의 길이보다 작도록 정해주어야 한다.
<=배열.length (X)
<배열.length (O) 

배열명까지만 선언하고 끝내는(;) 수도 있긴 하다.

- 예시
```
int[ ] arry = new int[6];
하면 정수 6개 들어갈 칸이 있는 arry라는 이름의 배열이 생성된다. 

이후에 
array[0] = 1;
array[1] = 2;
array[2] = 3;
.
.
.
array[5] = 6;
의 작업을 통해 값을 넣어주어야 한다.
```

2. 배열 선언과 값 저장을 같이 하는 방법도 있다.

> ==변수타입[ ] 변수명 = {값1, 값2...};==

- 예시
```
int[] arr = {1, 2, 3};
하면 1, 2, 3을 원소로 갖는 arr라는 배열이 만들어진다.
```
1) 같은 줄에 앉은 친구들 이름을 넣는 배열 만들기
 ```
 private void method3() {
		/*
		 * 배열 선언 후 같은 줄에 앉은 친구들 이름 넣는 배열 만들기
		 */
		System.out.println("이름을 입력해 주세요.");
		
		//배열 길이를 먼저 정해줍시다. 내 줄은 2명 앉았으니 [2]
		String[] arr = new String[2];
			
		for(int i=0; i<arr.length; i++) { //지정된 길이가 arr의 길이(.length)만큼 반복된다.
			arr[i] = sc.nextLine(); //사용자가 지정된 횟수만큼 입력을 반복
		}
		
		for(int i = 0; i<arr.length; i++) { 
			//이 반복문에서 출력을 해 줘야 i번째 배열이 차례대로 출력됨.
			System.out.print(arr[i] + " ");
		}
		
	}

 ```

###### 배열에 값 집어넣기

배열의 값을 넣어주지 않은 채 배열 변수(우리가 배열명으로 지정해준 것)를 선언한 후에는 다른 실행문에서 값 목록으로 배열을 생성할 수 없게 된다. 무슨 소리냐면, 

> ==변수타입[ ] 배열명 = new 변수타입[숫자];==

이 방법을 통해 생성한 배열에
배열명 = {값0, 값1, 값2, 값3..} ; 을 집어넣으면 컴파일 에러가 난다는 소리다.
이럴 경우에는 
배열명[인덱스번호] = 값; 을 하나하나 해주어야 한다.
arr[0] = 1; 이런 식으로 말이다.

그런데 배열변수, 즉 배열명이 먼저 정해지고 나중에 값이 오는 경우도 있지 않느냐?
그럴 때에는 new 연산자를 사용하여 값의 목록을 지정할 수 있다.

> ==배열명 = new 타입[]{값0, 값1, 값2, 값3....};== 

을 하면 이제 먼저 이름만 만들어 놓았던, 또는 이름과 자리만 만들어 놓았던 배열에 값을 넣을 수 있게 된다.

###### 배열에서 특정 원소만 삭제하기
```

    public int[] remove(int[] numlist, int index){
        //원본배열보다 하나 작은 배열을 만들어준다.
        int[] temp = new int[numlist.length-1];
        int num=0;
        for(int i=0; i<numlist.length; i++){
            //내가 지정한 숫자의 경우에는 배열에 값이 들어가지 않고 num값만 증가한다.
            if(i==index) continue;
            temp[num++] =numlist[i];
        }
        return temp;
    }

```


##### 배열의 값 나열하여 출력하기
###### for문을 통한 출력
```
	for(int i=0; i<배열명.length; i++) {
		System.out.println(배열명[i]);
	}
```

###### Arrays.toString을 통한 출력
```
System.out.println(Arrays.toString(배열명));

```
위의 입력을 통해 출력할 수 있다. 그러나, 이 방법은 java.util.Arrays;를 import해야 사용할 수 있다.

##### 배열의 값 정렬하기: <u>버블 정렬</u>과 <u>선택 정렬.</u>
 a라는 물그릇에 담긴 물과 b라는 물그릇에 담긴 물을 교환하려면 빈 c라는 물그릇이 또 필요하다. 같은 원리로 temp라는 변수를 만들어 임시로 값을 옮기는 것으로 원소의 자리를 교환할 수 있다.

###### 버블 정렬
```
private void method1() {
		//정렬할 배열을 만들어주자. 배열 선언과 값 저장을 동시에 했다.
		int[] arr = {30, 85, 70, 95, 55}; 
		
		//양옆의 숫자만이 아니라 배열 전체를 바꿔줘야 하므로 넣어주는 for문
		//0, 1, 2, 3, 4가 있다고 치면 i반복은 0차례가 왔을 때 0과 1234를,
		// 1차례가 왔을 때 1과 234를 비교하는 반복을 해 줄 거이다.
		for (int i = 0; i < arr.length-1; i++) { 
			//양옆의 숫자를 비교해서 큰수와 작은 수를 바꾸는 for문.
			//현재값이랑 다음값이랑 비교하므로 length에 -1를 해주자(마지막놈은 옆이 없으니까)
			for (int j = 0; j < arr.length-1; j++) { 
				if(arr[j]<arr[j+1]) { 
					//arr [j] 값을 temp에  임시저장, 빈 물통과 같은 개념
					int temp = arr[j]; 
					//빈 arr [j] 자리에 arr[j+1]값을 넣어준다.
					arr[j]= arr[j+1]; 
					//빈 arr[j+1]자리에 arr[j] 값을 넣어준다.
					arr[j+1] = temp; 
				}
			}
		}
		//정렬되는 과정이 끝나고서야 배열이 원하는대로 출력될것이다. 밖에서 출력해주자.
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i]+"\t");
		}
	}
```

###### 선택 정렬

```
private void method1() {
		//정렬할 배열을 만들어주자. 배열 선언과 값 저장을 동시에 했다.
		int[] arr = {30, 85, 70, 95, 55}; 
		/*
		 * 버블정렬은 두개씩 비교해서 정렬했으나
		 * 선택정렬은 현재값중에 제일 작은 것을 찾아서 가지고 오는 알고리즘이다.
		 */
		 
		// i반복은 배열 전체를 훑어줄 것이다. 잘 모르겠으면 버블정렬에 써둔 설명을 보자.
		for (int i = 0; i < arr.length; i++) {
			// j반복은 옆의 원소와 자신을 비교해서 조건에 맞는 경우가 나오면 자리를 바꾼다.
			// 그런데 비교대상을 j와 j+1로 하지 않고, 앞에 쓴 i를 재활용했다.
			for (int j = 0; j < arr.length; j++) {
				if(arr[i]>arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i]+"\t");
		}
	}
```


##### 디버깅 
런버튼 왼쪽의 귀여운 딱정벌레 아이콘.
행 번호 왼쪽에서 파란색 핀(더블클릭)으로 위치를 지정해 준 후에 쓰면 된다.
resume키(F8)을 누르면 다음 핀으로 가고, F6으로 누르면 다음 줄로 갈 수 있다.
옆의 Variable창에서 메모리에 할당된 변수 값을 볼 수 있다. 여러 번 누르면 반복문에서 실시간으로 값이 어떻게 변하는지 볼 수 있다.

##### 퍼스펙티브
다른 모드가 되면 화면을 모드에 맞는 세팅으로 바꿔주는 것.
왼쪽 위 버튼에서 화면구성이 미리 셋팅된 아이콘이 있어서 누르면 원래 화면 뷰로 돌아갈 수 있다.
window > show view에서 없어진 창을 다시 켤 수 있다.
