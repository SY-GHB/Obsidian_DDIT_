#### 단어 맞추기 게임
아침에 코딩테스트 예제를 몇 개 풀어보면서 시작했는데, 우리가 배열의 원소인 문자열에서 문자를 떼어오는 걸 못 해서 단어맞추기 게임을 만들어 보았다.

- str.charAt(번호) : 원하는 문자열의 인덱스 입력해서 가져오기
-  문자열 전체를 문자 배열로 분할하기
```
String str1
char ch[] = toCharArray = str1.toCharArray();
```

이걸 활용해서 단어맞추기 게임을 만들었다.

```
import java.util.Arrays;
import java.util.Scanner;

public class HangMan {
	Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		HangMan obj = new HangMan();
		obj.process();
	}
	private void process() {
		/*
		 * 문자열 맞추는 게임 ooooo ex) 정답: apple a 입력시 aoooo 완료될때까지 시행
		 */
		String question = "apple";
		char[] answer = new char[question.length()];
		for (int i = 0; i < question.length(); i++) {
			answer[i]='ㅁ';
		}
		int num=0; //횟수를 사용하는데 세어 줄 것이다.
		while (true) {
			for (int i = 0; i < question.length(); i++) {
				// 빈 칸 출력
				System.out.print(answer[i]);
			}
			// 문자열 입력 받기
			System.out.println(" ");
			System.out.println("문자를 하나 입력해 주세요.");
			String str = sc.nextLine(); //사실 여러개 입력해도 된다.
			char ch = str.charAt(0); // 여기서 인덱스0번, 즉 첫글자만 떼올거니까.
			
			// 같은 문자가 있다면 빈칸을 영어로 바꾸기
			for (int i = 0; i < question.length(); i++) {
				if(ch == question.charAt(i)) {
					answer[i] = ch;
				}
			}
			
			num++; //while문 안에 카운트기를 넣어주어야 카운트가 되겠지...
			
			// 처음에 게임이 안 끝나길래 뭐지 했더니
			// compare을 공백부터 시작하게 만들어서 안 멈추었던 것이었다.
			// 디버깅 기능을 잘 활용하자.
			String compare = "";
			for(int i=0; i<answer.length; i++) {
				compare += answer[i];
			}
			if(compare.equals(question)) {
				break;
			}
		}
		System.out.println("정답입니다.");
		System.out.println(num + "회 만에 맞추셨습니다.");
		// 정답을 맞추면 완료
	}
	// 실행하는 데 걸린 횟수 출력해주기
}
```

변수명을 통해서 이 데이터가 무슨 데이터인지 보다 명확하게 해 줌 
우리가 처음 만든 배열은 인덱스번호만 보고 무슨 변수인지 알 수 없었고 변수의 타입을 하나로(우리는 평균을 int로 했었다)고정할수밖에 없었다.

#### 책6-1 객체 지향 프로그래밍(Object-Oriented Programming)
##### ★) 객체지향 프로그래밍의 4가지 특징: 추상화, 상속, 다형성, 캡슐화
[출처](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)

객체지향 프로그래밍은 컴퓨터 프로그램을 여러 독립적인 부품들, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다.
###### a. 추상화 (Abstration)
사전적 의미로는 “사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것”
핵심은 "공통성과 본질을 모아 추출"한다는 것이다.
객체지향 프로그래밍에서는 "객체의 공통적인 속성과 기능을 추출하여 정의하는 것"을 의미한다.

java에서 추상화를 구현할 수 있는 문법요소로는 아래 두가지가 있다.
- 추상 클래스
	자식 클래스에서 반드시 오버라이딩(재정의)해야만 사용할 수 있는 메소드를 추상 메소드라고 하고, 하나 이상의 추상 메소드를 포함하는 클래스를 추상 클래스라 한다.
- 인터페이스
	어떤 객체가 수행해야 하는 핵심적인 역할만을 규정해두고, 실제적 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록 하는 일종의 추상클래스. 오로지 추상메소드와 상수만을 포함할 수 있다.
	==> 역할과 구현의 분리

###### b. 상속 (Inheritance)
기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소.
상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.

클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 재사용할 수 있어 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 한다.

###### c. 다형성 (Polymorphism)
어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 객체 지향의 특성.
메소드 오버라이딩과 메소드 오버로딩이 이에 속한다.
- 메소드 오버라이딩: 같은 이름의 메서드가 상황에 따라 다른 역할을 수행하는 것
- 메소드 오버로딩:  하나의 클래스 내에서 같은 이름의 메소드를 여러 개 중복하여 정의하는 것

```
객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미합니다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다.

ex) 음식 타입의 참조변수로 피자, 치킨, 탕수육, 족발, 케이크...를 참조할 수 있게 함.
```

###### d. 캡슐화 (Encapsulation)
클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것.

외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록 하여 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적으로 활용한다.
- 데이터 보호(data protection) – 외부로부터 클래스에 정의된 속성과 기능들을 보호
- 데이터 은닉(data hiding) – 내부의 동작을 감추고 외부에는 필요한 부분만 노출

캡슐화를 구현하는 방법은 두가지가 있는데,
- 접근제어자 활용: 해당 클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한한다.]
	![[Pasted image 20240114154250.png]]
- getter/setter메소드를 활용한다. [[23-11-16 패키지와 접근 제한자|필기참조]]



##### 1. 객체
객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것을 말한다.
객체는 속성과 동작으로 구성되어 있으며, 자바에서는 이 속성과 동작을 각각 <u>필드</u>와 <u>메소드</u>라고 부른다.
	ex) 사람의 속성에 이름, 나이가 있고 동작에 웃다, 먹다가 있으면
	사람 객체의 필드는 이름, 나이가 있고 메소드는 웃다, 먹다가 되는 것이다.

##### 2. 메소드
사람이 계산기를 쓰듯이, 객체들 사이도 상호작용을 하는데 그 수단이 되는 것이 메소드이다. 이 때, 객체가 다른 객체의 기능을 이용하는 것을 <u>메소드 호출</u>이라 한다.
	==리턴값 = 객체.메소드(매개값1, 매개값2...);== 의 형태다.
	- 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술한다. 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다.
	- 매개값은 메소드를 실행하기 위해 필요한 데이터다.
	- 리턴값은 메소드가 실행되고 난 후 호출한 곳으로 돌려주는 값이다.

##### 3. 객체와 클래스, 클래스 선언
객체는 하늘에서 뚝 떨어지는 것이 아니므로 설계도를 바탕으로 만들어줘야 하는데, 자바에서는 이 설계도를 클래스라고 하며 이 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.

사용하고자 하는 객체를 구상했다면 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로한다. 클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라 만들어야 한다.
	하나 이상의 문자로 이루어져야 한다.
	첫 글자에는 숫자가 올 수 없다.
	$, _ 외의 특수 문자는 사용할 수 없다.
	자바의 예약어, 키워드는 사용할 수 없다.
	클래스 이름이 단일 단어라면 첫 글자는 대문자이다.
	서로 다른 단어가 혼합된 이름을 사용한다면 각 단어의 첫 글자는 대문자이다.

클래스 이름을 정했다면 클래스이름.java로(클래스이름과 대소문자가 같아야 함.) 소스파일을 작성하고, 클래스를 선언해준다.
	==public class 클래스이름{
	}==
	public class는 소문자이다. 
	{는 클래스 선언의 시작을, }는 클래스 선언의 끝을 알려준다.

2개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은 클래스를 선언한 수만큼 생긴다. 즉, <u>소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐</u>, 클래스 자체가 아니다.

##### 4. 객체 생성과 클래스 변수
클래스로부터 객체 생성: new 사용.
	==new 클래스();==

new는 클래스로부터 객체를 생성시키는 연산자다. new 연산자 뒤에는 생성자가 오는데, 
생성자는 클래스()형태를 갖고 있다.
new연산자는 <u>메모리 heap힙 영역에 객체를 생성하고, 객체의 번지를 리턴하는데 이를 참조타입인 클래스 변수에 저장</u>해두면<u> 변수를 통해 객체를 생성</u>할 수 있다.
다음은 클래스로 선언된 변수에 new 연산자가 리턴한 객체의 번지를 저장하는 코드다.
	==클래스 변수;
	변수 = new 클래스();==
	or
	==클래스 변수 = new 클래스();==
```
우리가 Student s1 = new Student(); 라고 입력했던 것을 설명하는 내용이다.
만약  Student s2 = new Student(); 를 더 입력한다면, Student 객체가 또 생기지만
s1과 s2에 저장된 Student 객체들은 서로 다른 객체이다.
```
###### 클래스의 용도
-  라이브러리(API, Application Program Interfae)
	다른 클래스에서 이용할 목적으로 설계된다.
-  실행
	프로그램의 실행 진입점인 main()메소드를 제공한다.

##### 5. 클래스의 구성
클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 이 구성 멤버들은 생략, 복수작성이 가능하다.
```
pulic class ClassName{
	//필드: 객체의 데이터가 저장되는 곳
	int fieldname;
	
	//생성자: 객체 생성 시 초기와 역할 담당
	ClassName() {....}
	
	//메소드: 객체의  동작에 해당하는 실행 블록
	void methodName() {....}
}
```

###### 1) 필드
<u>객체의 고유 데이터, 부품 객체, 상태 정보를 저장</u>하는 곳.
선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않는다.
변수와의 다른 점: 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재

###### 2) 생성자
new 연산자로 호출되는 특별한 중괄호{}블록.
<u>객체 생성 시 초기화 담당</u>, <u>필드를 초기화하거나 메소드를 호출</u>해서 객체를 사용할 준비를 한다. 
메소드와 비슷하게 생겼지만, 클래스 이름으로 되어있고 리턴 타입이 없다.

###### 3) 메소드
객체의 <u>동작</u>에 해당하는 중괄호 {}블록.
이 중괄호 블록은 이름을 갖고 있는데, 이것이 메소드 이름이다.
메소드를 호출하면 중괄호 블록의 모든 코드들이 일괄적으로 실행된다.
필드를 읽고 수정하거나, 다른 객체를 생성해서 다양한 기능을 수행한다.
메소드는 객체 간의 데이터를 전달하는 수단: 외부로부터 매개값을 받아 실행에 이용, 실행 후 결과값을 외부로 리턴할 수도 있다.


#### 책6-2 필드
필드는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳.
자동차를 예로 들자면 아래와 같다고 할 수 있다.
```
고유 데이터: 제작회사, 모델, 색깔, 최고 속도
상태 데이터: 현재 속도, 엔진 회전 수
부품: 차체, 엔진, 타이어
```
따라서 자동차 클래스를 설계할 때 이 정보들은 아래와 같이 필드로 선언되어야 한다.
```
자동차 클래스
public class Car{
	//고유 데이터
	String company;
	String model;
	String color;
	int maxSpeed;

	// 상태 데이터
	int speed;
	int rpm;

	// 부품 데이터
	Body body;
	Engine engine;
	Tire tire;
}
```

##### 1. 필드 선언
클래스 중괄호 블록 어디서든 존재할 수 있으나
생성자와 메소드 중괄호 블록 내부에서는 선언될 수 없다: 여기서 선언된 것은 로컬 변수가 된다.
<font color="#bfbfbf">클래스 멤버 변수라고도 부르지만, 되도록 필드라는 용어를 사용하자.</font>
	==타입 필드 [=초기값] ;== 의 형태다.
	타입에는 기본 타입과 참조(배열, 열거, 인터페이스)타입이 모두 올 수 있다.
	초기값은 생략이 가능하다.


##### 2. 필드 사용
필드값을 읽고 변경하는 작업.
클래스 내부의 생성자나 메소드에서 사용할 경우엔 단순히 필드 이름으로 읽고 변경 가능.
클래스 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤에 필드를 사용할 수 있다.
	필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문.
```
 Car클래스의 필드에서 speed를 선언했다면, Car클래스 안 생성자나 메소드에서는 그냥 speed=0;으로 값 변경이 가능하지만,

 Car class{
 int speed;
 
  Car(){
  speed=0;}
  
  void method(...){
  speed=10}
  
  }
  
Person클래스에서는 Car 객체를 생성하고 나서야 필드의 사용이 가능하다.
 void method(){
 //Car 객체 생성
 Car myCar = new Car();

 //필드 사용, 도트 연산자를 통해 speed 필드에 접근할 수 있다.
 myCar.speed=60;

 }

```
도트 연산자는 객체 접근 연산자로, 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용된다.


#### 코딩테스트

###### 문자열 뒤집기
-  문제: 문자열 `my_string`이 매개변수로 주어집니다. `my_string`을 거꾸로 뒤집은 문자열을 return하도록 solution 함수를 완성해주세요.
```
class Solution {
    public String solution(String my_string) {
        String answer = "";        
        char[] ch= my_string.toCharArray();
        for(int i=my_string.length()-1; i>=0; i--){
            answer += ch[i];
        }
        return answer;
    }
}
```
-  선정이유: 새로운 지식, 생각의 유연화
 문자열의 각 문자들을 떼어 배열로 만들어주는 char array = str.toCharArray(); 를 배울 수 있었고, 범위설정을 다르게 하는 법(초기화식이 꼭 =0;일 필요는 없다.)을 경험할 수 있었다.
