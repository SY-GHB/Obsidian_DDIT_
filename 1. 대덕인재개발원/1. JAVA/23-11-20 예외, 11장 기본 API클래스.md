
### 예외
#### 10-1 예외 클래스
예외(exception)란 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류로, 예외가 발생되면 프로그램은 곧바로 종료된다는 점에서 에러와 비슷하다.
그러나 예외 처리(exception handling)을 통하면 프로그램을 종료하지 않고 정상실행상태를 유지할 수 있다.
자바는 예외발생가능성이 높은 코드를 컴파일할때 예외 처리 유무를 확인해 예외처리 코드가 없다면 컴파일을 하지 않는데, 모든 예외에 대해서 예외 처리 유무를 확인하는 건 아니다. 그럼 뭘 하고 뭘 안 하나? ... 이것을 이해하려면 예외의 종류부터 알아야 한다.

##### 1. 예외와 예외 클래스
예외는 일반 예외(exception)와 실행 예외(runtime exception)으로 나뉜다.
- 일반 예외: 컴파일러 체크 예외라고도 한다. 프로그램 실행 시 예외발생가능성이 높기 때문에 컴파일과정에서 해당 예외 처리 코드가 있는지 검사하고, 예외처리코드가 없다고 하면 컴파일 오류가 발생한다.
	우리가 이클립스에서 코드를 입력하면서 빨간 줄이 생기는 것들이 일반 예외이다!

- 실행 예외: 컴파일러 넌 체크 예외라고도 한다. 실행 시 예측할 수 없이 갑자기 발생하기 때문에 컴파일하는 과정에서 예외처리코드가 있는지 검사하지 않는다.
	일단 코드 작동을 시켜 봐야 예외가 있는지 없는지 알 수 있는 종류의 것들이다.

자바는 예외를 클래스로 관리한다: JVM은 프로그램 실행 도중 예외가 발생하면 해당 예외클래스로 객체를 생상하고, 예외 처리 코드에서 예외 객체를 이용할 수 있도록 해 준다.
모든 예외 클래스는 java.lang.Exception 클래스를 상속받는다. 
RuntimeException의 하위 클래스가 아니면 일반 예외 클래스이고, 클래스 상속관계에서 부모(조상)에 RuntimeException이 있다면 실행 예외 클래스이다.

##### 2. 실행 예외
실행 예외는 자바 컴파일러가 체크하지 않기 때문에 오로지 개발자의 경험에 의해서 예외 처리 코드를 작성해야 한다. 작성하지 않는다면 예외 발생 시 프로그램이 바로 종료된다.
	실행예외가 발생하면 이유와 위치를 말해준다. 말해주는 위치 중 내가 작성한 코드 중 최상위 위치를 클릭하면 가장 세부코드를 집어준다.
###### 1) NullPointerExceptoin
자바 프로그램에서 가장 빈번하게 발생되는 실행 예외로, 객체 참조가 없는 상태, 즉 null값을 참조변수로 객체 접근 연산자(.)를 사용했을 때 발생한다. 객체가 없는데 객체를 사용하려고 하니 발생하는 예외이다.

###### 2)ArrayIndexOutBoundException
배열에서 인덱스 볌위를 초과할 경우 발생하는 실행 예외다. 익숙하지 않은가? 배열로 for문 쓸 때 많이 봤었다.

###### 3)NumberFormatException
Integer.parseInt()를 기억하는가? ()안에 문자열을 정수로 변환해서 리턴하는 함수였다.
NumberFormatException 은 parse□□□()메소드에 숫자로 변환될 수 없는 문자가 포함되어 있다면 발생하는 실행 예외이다.

###### 4)ClassCastException
#배우면_상속


#### 10-2 예외 처리
자바 컴파일러가 잡아주면 강제적으로, 아니면 우리가 알아서 예외 처리 코드를 작성해야 한다.
일반 예외는 강제적으로 잡아주지만 실행예외는 잡아주지 않으니 우리의 경험을 바탕으로 작성한다.

##### 1. 예외 처리 코드
try-catch-finally 블록은 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 해 준다.
![[Pasted image 20231120203547.png]]
1.  try 블록에는 예외발생가능성이 있는 코드가 위치한다.
	예외가 발생하면 예외 event가 발생되어 그게 어떤 예외인지 판별해준다.
2. 예외가 발생되지 않았다면 catch블록은 작동하지 않고 바로 finally로 내려간다. 예외가 발생하면 예외처리 후 finally로 내려간다.
```
책 464p, 반복문에서 다음 반복에 예외가 발생해서 catch블록이 작동했다면
finally블록에서 작동되는 실행문엔 이전 반복의 값이 할당된다.
```

- finally는 생략 가능하며, 예외 발생 여부와 상관없이 -*심지어 try와 catch블럭에서 return을 작성해도*-항상 실행되므로 꼭 실행되어야 하는 코드가 있다면 여기에 작성한다. 
``rs.close(); DB접속을 끊어주는 메소드라는데, DB에 접속하는 예시를 들어주셨어서 finally블록에서 이걸 쓰셨었다.``

사용자가 언제나 시키는 대로 입력하지는 않는다. 나는 숫자를 입력하라고 했는데 문자를 넣어놓거나 공백을 넣거나 할 때가 태반이다. 그러니 사용자 입력을 받는 경우에 예외 처리를 사용하는 경우가 많다.

##### 2. 예외 종류에 따른 처리 코드
###### 1) 다중 catch 
다양한 예외가 발생할 것 같을 때, 발생되는 예외별로 예외 처리 코드를 다르게 하면 다중 catch 블록을 작성하면 된다. 
try블록에서 동시다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch블록으로 이동하기 때문에 catch블록이 여러개라도 할지라도 단 하나의 catch 블록만 실행된다. 

###### 2) catch  순서 주의하기
상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다.
	try 블록에서 예외가 발생했을 때, 예외를 처리해줄 catch 블록은 위에서부터 차례대로 검색되는데 만약 상위 예외 클래스의 catch블록이 위에 있다면, 하위 예외는 상위 예외를 상속하여 하위 예외 클래스의 catch블록은 실행되지 않는다.
	==Exception은 예외처리에서 최상위 클래스이다!==

```
try{
	method1();
	
  }catch(Exception e){
  }catch(ClassNotFoundException e){
  }

이 경우에서 Exception이 가장 최상위클래스라 하위 예외인
ClassCastException의 catch문은 실행되지 않는다.
```

##### 3. 예외 떠넘기기
메소드 내부에서 예외발생가능성이 있는 코드를 작성할 때 보통은 try-catch로 예외를 처리하지만, 경우에 따라서는 <u>메소드를 호출한 곳으로 예외를 떠넘길 수도 있다.</u>
이 때 사용하는 키워드가 ==throws==로, 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 한다. throws 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해서 나열하면 된다.
```
리턴타입 메소드이름(매개변수, ...) throws 예외클래스1, 예외클래스2 .. {...}
```


모든 예외를 한꺼번에 떠넘기고 싶다면 아래와 같이 써도 된다.
```
리턴타입 메소드이름(매개변수, ...) throws Exception {...}
```

``**`` main 메소드에서 thorws Exception 을 붙이는 것은 좋지 못한 예외 처리 방법이다. 프로그램 사용자는 프로그램이 알 수 없는 예외 내용을 출력하고 종료되는 것을 좋아하지 않으므로, main()에서 try-catch블록으로 예외를 최종처리하는것이 바람직하다.


throw는 강제 예외 발생으로, 일반 메소드 내부에서 사용한다. 아래 형식으로 사용한다.
```
 *  throw 예외클래스 객체명
 *    	IoException ie = new IoException();
 *     ex throw new Exception();
 *        throw ie;
```
직접 에러를 발생시키고자 할 때 사용한다. 닉네임에 특정 단어를 포함시키고 싶지 않다거나 등의 이유로 사용할 수 있다.
예시를 보자.
 ```
 package kr.or.ddit.study10.sec02;

 import java.util.Scanner;

 public class ExceptionExample06 {
	static Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		ExceptionExample06 obj = new ExceptionExample06();
		while(true) {
			System.out.println("닉네임 입력: ");
			String nick = sc.next();
			
			try {
				checkNickName(nick);
				break;
			} catch (Exception e) {
				System.out.println(e);
			}
		}
	}
	
	public static void checkNickName(String name) {
		if(name.contains("바보")) {
			throw new NickNameException();
		}
		if(name.length()>10) {
			throw new NickNameException();
		}
	}
 }

 class NickNameException extends RuntimeException{
	public NickNameException() {
		super("잘못된 별명입니다.");
	}
 }
 ```
checkNickName 메소드에서 "바보"라는 단어를 포함하거나 10글자가 넘는 길이의 닉네임인 경우 throws로 NickNameException()에 보내주자고 작성했다.
그럼 NickNameException()메소드에서 받아 "잘못된 별명입니다."를 출력하게 된다.

### 기본 API 클래스
#### 11-1 java.lang패키지

java.lang패키지에 속하는 주요 클래스와 간략한 용도를 먼저 살펴보자.

|클래스|용도|
|---|---|
|Object| 자바 클래스의 최상위 클래스로 사용|
|System| 표준 입력 장치(키보드)로부터 데이터를 입력받을 때 사용,
| | 표준 출력 장치(모니터)로 출력하기 위해 사용|
| | 자바 가상 기계를 종료할 때 사용|
| | 쓰레기 수집기를 실행 요청할 때 사용|
|Class|클래스를 메모리로 로딩할 때 사용|
|String| 문자열을 저장하고 여러 가지 정보를 얻을 때 사용
|Wrapper|기본 타입의 데이터를 갖는 객체를 만들 때 사용.
| |문자열을 기본 타입으로 변환할 때 사용|
| |입력값 검사에 사용|
|Math|수학 함수를 이용할 때 사용|

##### 1. 자바 API도큐먼트
API(Application Programming Interface)는 라이브러리(Library)라고도 부르는데, 프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말한다. 

다음 URL은 방대한 자바 표준 API 중 우리가 원하는 API를 쉽게 찾아 이용할 수 있도록 도와주는 API도큐먼트이다. 필요하면 쓰자.
```
http://docs.oracle.com/em/java/javase/index/html
```
JDK8은 패키지별로 정리하여, 11이후 버전은 모듈별로 구분해서 정리해준다.


~이 부분은 보지 않고 넘겼다. 여유될 때 다시 돌아와서 보자.~
 ```
 ##### 2. Object 클래스
 Object클래스는 모든 클래스의 최상위 부모 클래스로, 클래스 선언 시 extends 키워드로 다른 클래스를 상속하지 않더라도 모든 클래스는 암시적으로 java.lang.Object를 상속한다.

 ###### 1) 객체 비교 equals();

 public boolean equals(Object obj){...}

 이렇게 생긴 메소드다. 매개타입이 object라는 건 모든 객체가 매개값으로 대입될 수 있다는 의미다.(모든 객체는 object로 프로모션될수있으니까)
 두 객체를 비교해서 논리적으로 동등하면 true를, 아니면 false를 리턴한다.
	논리적으로 동등하다: 같은 객체건 다른 객체건 객체가 저장하는 데이터가 동일하다.

 ##### 3. System 클래스
 ##### 4. Class 클래스

 ```
##### 5. String 클래스
###### 1) String 생성자
###### 2) String 메소드

자주 쓰이는 메소드

|리턴 타입|메소드 이름|설명|
|---|---|---|
|char|charAt(int index)|특정 위치의 문자를 리턴한다.|
|boolean|equals(Object anObject)|두 문자열을 비교한다.|
|byte[]|getBytes()|byte[]로 리턴한다.|
|byte[]|getBytes(Charset charset)|주어진 문자셋으로 인코딩한 byte[]로 리턴한다.|
|int|indexOf(String str)|문자열 내에서 주어진 문자열의 위치를 리턴한다.|
|int|length()|총 문자의 수를 리턴한다.|
|String|replace("1","2")|1(target)부분을 2(replacement)로 대치한 새로운 문자열을 리턴한다.|
|String|substring(int beginIndex)|beginIndex위치에서 끝까지 잘라낸 새로운 문자열을 리턴한다.|

486p부터~
- 문자 추출 charAt(): 매개값으로 주어진 인덱스의 문자를 리턴한다.

- 문자열 비교 equals(): 문자열을 비교한다.
	자바는 문자열 리터럴이 동일하다면 동일한 String객체를 참조하도록 되어 있지만, new 연산자로 생성된 객체를 참조한다면 리터럴이 같아도 다른 데이터가 된다.

- 바이트 배열로 변환 getBytes(): 문자열을 바이트 배열로 변환한다.
	네트워크로 문자열 전송, 문자열을 암호화할때 등에 사용한다.

- 문자열 찾기 indexOf(): 매개값으로 주어진 문자열이 시작되는 인덱스를 리턴한다.
	```
	String subject = "자바 프로그래밍"
	int index = subject.indexOf("프로그래밍");
	을 하면 index에는 3이 저장된다.
	```

- 문자열 길이 length(): 문자열의 길이 수를 리턴한다.

- 문자열 대치 replace("1", "2"):  1을 2로 바꿔준다.
	글자를 없애고 싶다면 2자리에 ""를 넣으면 된다. 데이터 중간에는 null 이 들어갈 수 없음.

- 문자열 잘라내기 .substring(3): 123456라는 문자열이 있다면 3부터  끝까지잘라내주는 방법
	.substring(3, 7) 123456789라는 문자열이 있다면 3부터 7 앞까지 잘라내주는 방법, 7은 포함되지 않는다.

- 알파벳 대/소문자로 변경 toLowerCase() .toUpperCase() 
	대소문자를 구분하지 않는 시스템의 경우에 사용하면 좋겠죠? 소문자나 대문자로 밀어놓고 서치하면되니까.

- ★ 문자열 앞뒤 공백 잘라내기 .trim()
	앞 뒤 공백을 없애주고 줄바꿈문자도 없애준다.
	앞뒤공백이 들어가면 다른 문자가 되니까 정말 중요한 기능이다! 
	대부분의 데이터는 trim을 통해서 한번 검사해줘야한다.
	그러나 문자 중간에 있는 공백은 데이터로 인식해서 없애지 않는다.

- 문자열 포함 검사 contains()
	문자열에 내가 검색할 문자열이 있는지 검사하는 것
	.equals()는 전체문자가 같아야하는데 contains는 검사만 하는 거니까 완전히 같을 필요까지는 없다.

-  문자 자르기 .split()[n]
	내가 원하는 문자를 넣고 그 문자를 기준으로 데이터를 잘라준다. 
	탭``\t``이나 줄바꿈``\r\n``, 콤마나 마침표로 잘린 데이터에 쓰기 좋다.
	n에 인덱스번호를 넣어 잘린 곳 기준의 앞뒤를 출력할 수 있다.


- 문자열 찾기 .startsWith() , .endsWithd()
	~로 시작하는/끝나는 문자열. 파일찾을 때 유용하다.

-  대소문자 무시 .equalsIgnoreCase("Y")
	대문자 Y와 소문자 y를 같은 걸로 인식해준다.
