#### 6-6. 패키지와 접근 제한자

패키지는 파일 시스템의 폴더기능을 하며 클래스를 유일하게 만들어주는 식별자 역할도 한다. 클래스의 전체 이름은 패키지이름.클래스이며, 패키지에도 단계의 구별이 있다면 
``상위패키지.하위패키지.클래스`` 순으로 기술한다.

보통의 인터넷주소-도메인 ddit.or.kr처럼 쓰인다. 그러나 ddit(대덕인재개발원♥)보다 co가, co보다는 kr이 더 큰 상위의 개념이므로 대덕인재개발원의 이름을 가진 패키지에서 클래스를 만든다면, ``kr.or.ddit`` 순으로 기술될것이다.

##### 1. 패키지 선언
클래스 작성 시 해당 클래스가 어떤 패키지에 속할 것인지를 선언하는 것으로, 
```
package 상위패키지.하위패키지;

public class ClassName { ... }
```
이라고 기술한다.
이클립스는 패키지 선언이 없는 클래스를 default 패키지에 포함시킨다. 사실상 패키지가 없다는 뜻으로, JDK 8 이전 버전에서는 패키지가 없는 클래스를 선언할 수 있지만 JDK11 이후 버전부터는 패키지가 없는 클래스를 생성하면 컴파일 에러가 난다.

패키지 또한 클래스의 일부로, 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스를 사용할 수 없다. 클래스를 이동하려면 패키지 전체를 이동시켜야 한다.
패키지 이름 역시 개발자가 임의대로 지어주면 되지만,
- 숫자로 시작할 수 없고, $와_을 제외한 특수문자는 사용할 수 없다.
- 모두 소문자로 작성하는 것이 관례다.
	(클래스이름은 대문자로 시작, 변수 이름은 소문자로 시작, 상수 이름은 모두 대문자.)
-  java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안 된다.

###### import문
사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면 import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려줘야 한다.

import문은 패키지 선언과 클래스 선언 사이에 작성하며, 갯수에 제한이 없고,
```
import 상위패키지.하위패키지.클래스이름;

//만약 사용할 클래스들이 같은 하위패키지 소속이라면 *(ALL의 의미)을 쓰는 것도 좋다. 
import 상위패키지.하위패키지.*;

import java.util.Scanner;
import java.util.*;
```
의 형식으로 작성한다. 

상위패키지를 import했다고 하위패키지까지 전부 import된것은 아니라는 점을 주의하자.
경우에 따라서는 import문과 상관없이 패키지가 포함된 클래스 전체 이름을 코드에 기술해야 할 때가 있는데, 서로 다른 패키지에 동일한 클래스 이름이 존재하고 그 두 모두를 import한다면 컴파일러는 어떤 클래스를 사용해야 할지 모호해지므로 컴파일 에러를 발생시킨다. 이 경우에는 정확하게 패키지가 포함된 클래스 전체 이름을 기술하자.


##### 2. 접근 제한자(Acess Modifier)
접근제한자는  클래스 및 인터페이스,  그리고 이들이 가진 멤버의 접근을 제한하는 데 사용된다.
	클래스와 인터페이스를 다른 패키지에서 사용하지 못하게 할 때,
	객체 생성을 막기 위해 생성자를 호출하지 못하게 할 때,
	필드나 메소드를 사용하지 못하게 할 때 등에 사용한다.

↓ **public** 접근 제한자: 외부 클래스가 자유롭게 사용할 수 있다.
↓ **protected** 접근 제한자: 같은 패키지 또는 다른 패키지의 자식 클래스에서 사용할 수 있다.
↓ **private** 접근 제한자: 외부에서 사용할 수 없다.

의 순으로 범위가 좁아진다. 위 세 경우에 속하지 않는 경우, default 접근 제한자를 가지는데,

↓  **default** 접근 제한: 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 한다.

<접근제한의 종류와 적용할 대상>

|접근 제한자|적용 대상 |접근할 수 없는 클래스|
|---|---|---|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스, 필드, 생성자, 메소드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메소드|모든 외부 클래스|

```
protected 접근 제한자는 다른 패키지에 소속되더라도 자식 클래스면 접근할 수 있다.
단, 다른 패키지의 자식 클래스라면 new 연산자를 사용해서 생성자를 직접 호출할 수는 없고, 자식 생성자에서 super()로 A 생성자를 호출해야 한다. 
```

##### 3. Getter와 Setter 메소드

예를 들어, 자동차라는 객체가 있고 그 속력을 변경한다고 치자. 그런데 속력을 -100으로 넣었다면?
이 자동차라는 객체는 객체의 무결성이 깨졌다고 볼 수 있다. 이러한 일을 막기 위해. 일반적으로 객체 지향 프로그래밍에서는 객체의 필드를 객체 외부에서 직접적으로 접근하지 못하게 막는다. 
하지만 사용자가 속력을 바꾸긴 해야 할 것 아닌가? 같은 속력으로 영원히 돌면 그게 자동차냐 에스컬레이터지?

이럴 때 객체 지향 프로그래밍에서는 Getter와 Setter 메소드를 사용한다.
클래스를 선언할 때 가능하다면 필드를 private 로 선언해 외부로부터 보호하고,
필드에 대한 Setter와 Getter 메소드를 작성하면 필드값을 안전하게 변경/사용할 수 있다.
그래서 그게 뭔데?
###### 1) Setter: 
필드는 외부에서 접근할 수 없도록 막고 / 메소드는 공개해서
외부에서 메소드를 통해 필드에 접근하도록 유도한다.
이런 방법을 사용하면 메소드가 <u>매개값을 검증해서 유효한 값만 객체의 필드로 저장</u>할 수 있게 되는데, 이 역할을 하는 메소드가 바로  Setter이다.

###### 2) Getter
외부에서 객체의 데이터를 읽을 때도 메소드를 사용할 수 있다.
필드값을 직접 사용하면 부적절한 경우엔 <u>메소드로 필드값을 가공한 후 외부로 전달</u>할 수 있으며 그 역할을 하는 메소드가 Getter이다.
	부적절한 경우가 언제일까?
	책의 예시는 자동차의 속도를 마일에서 km단위로 환산하는 경우였다. 

###### 3) Getter/Setter  선언
```
//private 접근 제한자를 통해 필드를 선언해주자.
priavte 타입 fieldName 

// 여기서의 리턴타입은 필드의 타입이다. 
// Getter의 접근 제한자는 public이여야 이용자가 접근을 할 수 있지!!
// 메소드 이름은 get+필드이름(첫글자는 대문자)
public 리턴타입 getFieldName(){
	// 여기에 반환코드를 넣으시오
	// ~필요에 따라~
	return fieldName;
}

// Setter 역시 접근제한자는 public이여야 이용자가 접근할테다.
// 매개변수 타입은 필드의 타입이다.
// 매개변수와 필드의 이름이 같으니 필드 앞에는 this를 붙여주자.
public void setFieldName(타입 fieldName){
	// 여기에 검증코드를 넣으시오
	// ~필요에 따라~
	this.fieldName = fieldName;
}

```

필드의 타입이 boolean인 경우, Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례다.
 ```
 public boolean isStop(){
	 return stop;
 }
 ```
이런 형태!

만약 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면
Getter 메소드만 선언하거나, Setter메소드에 private 제한을 갖도록 하면 된다.