
1단계: 요구사항 명세서 requirment specification
IEEE에서 포맷을 이미 뿌려줬음

요구사항이 명세서상태로(문서로) 수집되어있다고 치자
비슷한 일끼리 모아서(요구사항을 정제해서-단문형으로 쓰는 게 좋다.)
use-case-diagram이 잘 그려지면 데이터베이스를 잘 구성한 것이다.
unified modeling language? uml 정적다이어그램 동적다이어그램 인터랙티브다이어그램??


목적: 사용자의 요구 사항을 분석하여 개발할 데이터베이스의 용도를 파악
	업무에 필요한 데이터가 무엇인지, 그 데이터에 어떤 처리가 필요한지 등을 고려.

결과물: 요구사항 명세서

주요작업
- 데이터베이스를 실제로 사용할 주요 사용자의 범위를 결정
- 사용자가 조직에서 수행하는 업무를 분석
- 면담. 설문조사.업무관련 문서 분석 등의 방법을 이용해 요구 사항 수집
- 수집된 요구사항에 대한 분석결과를 정제하여(같은 처리를 해주는 것끼리 모아서-동사를 보면 모을 수 있다. 동사 앞의 명사가 두개면 관계를 갖는다.)요구사항 명세서로 작성
	고유명사는 제외시켜야 한다. 서로 포함(주종)관계에 있는 단어를 찾는다. 포함하는 단어는 엔터티, 포함되는 단어는 속성이 된다.
	엔터티(속성, 속성,...)으로 써보자. ex 회원(회원아이디, 이름, 비밀번호) 그중에서 업무식별자는 줄을 그어보자. 
	일단 제일 중요한 속성만 골라내본다.
	업무식별자: 그놈이 바뀌면 데이터가 바뀌는 것 ex)회원번호
	업무식별자가 키가 될 수도 잇고 부적절하다고 판단될수도잇다

--------------------------------------------------------------------------------------------------------------
2. 개념적 설계
entity, attribute, relationship을 끄집어내는 단계
이걸 끄집어내서 그림으로 그린 게 ERD(Entity-Realtionship Diagram)

3. 논리적 설계
논리모델부터는 다:다의 차수가 쓰이지 않는다?? 논리모델부터는 다대다 관계를 허용하지 않는다.
entity가 relation으로, relation이 테이블로 변환된다.
attribute는 필드로 변화된다.
정규화를 한다. 1,2,3,v-c,4,5정규의 총 6개
정규화의 원흉: 데이터 중복 이걸 해결하기 위해 정규화를 한다(데이터 무결성을 지키기 위해)
정규화를 수행하면 보통 테이블 분할이 발생된다: 정보를 나눠서 저장한다는 얘기다>조인이 발생되어야 한다.
쪼개서 얻는 이득보다 손실이 더 큰 경우에는 반(reverse)정규화를 한다.(우편번호와 주소를 같은 테이블에 보관하기, 3정규화 위배임)

일단 모든 엔터티는 릴레이션으로 변경한다

규칙1. 모든 개체는 릴레이션으로 변환한다.
	개체의 이름은 릴레이션 이름,
	개체의 속성은 릴레이션의 속성,
	개체의 업무식별자는 릴레이션의 기본키로 변환.
	  기본키의 속성(not null, no duplicate)을 가지고 있다면 기본키가 될 수 없으나 그렇지 않다면 인조식별키?를 만들어줘야 한다.
	개체의 속성이 복합 속성인 경우에는 복합 속성을 구성하고 있는 단순 속성만  릴레이션의 속성으로 변환
	  ex)주소는 복합속성, 그 구성원이 되는 기본주소, 상세주소는 단순속성이다.

규칙2: 다대다 관계는 릴레이션으로 변환한다.
	관계형 데이터베이스에서는 다대다 관계를 허용하지 않는다.
	다대다 관계에서 관계를 릴레이션(테이블)로 변환해주면 된다. n:m이 1:n, m:1로 나뉜다.
	IE(정보공학식) 표현방법, Baker식 표현방법이 있다.

규칙3 일대다관계는 외래키로 표현한다.
	3-1 일반적인 일대다관계는 외래키로 표현한다. (외래키의 행이 하나도 없을경우에 삼지창앞에 동그라미그려주기♡)
	- 일대다 관계에서 1측 개체 릴레이션의 기본키를 n측 개체 릴레이션에 포함시켜 외래키로 지정,
	- 관계의 속성들도 n측 개체의 릴레이션에 포함시킨다.
	관계에 속성이 있을 경우 자식쪽으로 밀어서 엔터티를 만들어줘라???? x 별도의 릴레이션에서 만들어줘라 o(주요릴레이션)

	3-2 약한 개체가 참여하는 일대다관계는 외래키를 포함해서 기본키로 지정한다.
	- 일대다(1:n) 관계에서 1측 개체 릴레이션의 기본키를 n측 개체 릴레이션에 포함 시켜 외래키로 지정
	- 관계의 속성들도 n측 개체 릴레이션에 포함시킴(권장하는 방법은 아니다.)
	- n측 개체 릴레이션은 외래키를 포함하여 기본키를 지정함
	   (약한 개체는 오너 개체에 따라 존재 여부가 결정되므로 오너 개체의 기본키를 이용해  식별해야 함)

규칙4 일대일 관계는 외래키로 표현한다.
부모의 외래캐가 없어도 완벽하게 식별이 되면 굳이 식별관계일 이유는 없다.
근데 안 되면 식별관계로 pk를 받아와야 한다.

	4-1 일반적인 일대일 관계는 외래키를 서로 주고 받는다
	4-2 일대일 관계에 필수적으로 참여하는 개체의 릴레이션만 외래키를 받는다.
	4-3 모든 개체가 일대일 관계에 필수적으로 참여하면 릴레이션을 하나로 합친다.


규칙5: 다중 값 속성은 릴레이션으로 변환한다.

변환규칙을 순서대로 적용하되, 해당되지 않는 규칙은 제외함.



정규화란: 데이터베이스 설계 시 중복을 최소화하도록 데이터를 구조화하는 작업
정규화를 하는 목적: 이상(anomaly)이 있는 관계를 재구성함으로서 바람직한 스키마로 구성

update anomaly / insert anomaly, deltet anomaly가 있다. 가장 주된 원인은 데이터 중복!



1정규화의 전제조건(필요충분조건): 각 항목은 원자값을 가져야 한다. 각 컬럼은 한 값만을 가져야 한다는 것이다.
   ex)나이에 36살.만 들어와야하지 10살이고 20살인 동시에 30살일 수는 없는 것이다.(다가속성)
	제1정규화로 분리된 테이블만 자식테이블이고 나머지 정규화에 의해 분리된 테이블은 원테이블의 부모테이블이 된다.

2정규화: 기본키가 두개 이상으로 구성되었을 때 발생. 부분종속? 하나의 기본키에만 종속되고 나머지 하나에는 종속되지 않을 경우 위배
자신을 종속하는 속성을 데리고 분가해서 부모가되..되면되나
일반속성 중 주 식별자 전체에 종속적이지 않은 속성을 찾아 기본 엔터티에서 제거하고 그 속성의 결정자를 주 식별자로 하는 새로운 상위 엔터티를 생성

3정규화: 기본키냅두고 일반항목에 종속되었을 때 위배
비 식별자(일반속성)간에 발생하는 이행적 종속성과 관련된 정규화
x>y이고 y>z이면 x>z가 성립.
이때 y가 릴레이션 식별자가 아닌 일반 속성일 때 y가 z를 데리고 새로운 엔터티로 가서 y가 기본키가 된다..


b-c(3정규화의 특수한 경우): 기본키가 일반항목에 종속된 경우 위배
3정규화를 보강한 정규형
모든 bc정규형은 모두 3정규형 릴레이션이지만 모든 3정규형이 모두 bc정규형 릴레이션이 아님
모든 결정자는 주 식별자여야여야 함-릴레이션에 존재하는 종속자는 후보식별자가 아니어야 함.


~45정규화는 잘 안한다.~
4정규화:다가종속이 발생된 경우 위배
사원번호-기술-언어가 있을 때 사원번호-언어 사원번호-기술 테이블로 나눈다.
여기서 조인을 했을 때 원래테이블과 같은 형태로 돌아가면 5정규화에 위배되지 않는다.

5정규화: ??조인종속이 발생됐느냐 아니냐?



함수종속
데이터의 종속성에는 함수종속/다가종속/조인종속/파생종속 등이 존재
함수종속은 릴레이션 내에 존재하는 속성 간의 종속성 의미
즉, 릴레이션에서 a속성의 값이 b속성의 값을 유일하게 식별할 수 있다면 b속성은 a속성에 함수적으로 종속되었다고 함

결정자와 종속자
결정자: 종속성 분류시 기준이 되는 값. 결정자가 바뀌면 다 바뀌어야 한다.(예: 주민등록번호)
종속자: 결정자의 값에 의해 정해질 수 있는 값(예: 집주소)


이행종속 만약 x-y-z종속이 있다면 z는 x에 간접적으로 종속되어있음, 이를 이행종속(Transitive dependendcy)라 하며 같은 엔터티로 설계해선느 안됨.
직접 종속인 x와 y y와 z를 별도의 엔터티로 설계(3정규화)

--------------------------------------------------------------------------------------------------------------
4. 물리적 설계: 실제 사용할 dbms, 하드디스크의 분할, 전체 테이블이 너무 잘게 조각나있으면 통합?
최적화에 관련된 내용이 포함됨
--------------------------------------------------------------------------------------------------------------
5. 구현

