## SOLID 원칙
미뤄두었던 SOLID원칙을 정리할 때가 왔다...
[출처](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
좋은 소프트웨어란 변화에 대응을 잘 하는 것이고, 좋은 설계란 새로운 요구사항이나 변경사항이 있을 때 영향을 받는 범위가 적은 구조를 말한다. 예상치 못한 변경사항이 있을 때 유연하게 대응할 수 있는 확장성 있는 시스템 구조를 말하는 것이다.

SOLID 객체 지향 원칙을 적용하면 좋은 소프트웨어를-코드를 확장하고 유지보수하기가 쉬운 프로그램을 만들 수 있다.
### S. 단일 책임의 원칙(SRP, Single Responsibility Principle)
하나의 모듈이 하나의 책임(기능 담당)을 가져야 한다, 즉 모듈이 변경되는 이유가 한 가지여야 한다.
프로그램의 유지보수성을 높이기 위한 설계기법이다.
### O. 개방 폐쇄 원칙 (Open-Closed Principle, OCP)
확장에는 열려 있어야 하며, 수정에는 닫혀 있어야 한다.

기능 추가가 필요할 때 클래스 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화하는 프로그램을 작성하는 설계 기법이다.

확장에 열려있다는 것은 변경사항이 있을 때 유연하게 코드를 추가함으로서 큰 힘을 들이지 않고 기능을 확장할 수 있다는 것을 의미하고,
변경에 닫혀있다는 것은 변경사항이 있을 때 객체의 직접적인 수정을 제한한다는 의미이다.

구체적으로 말하자면, 추상화 사용을 통한 관계 구축을 권장한다는 의미다.
### L. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
[더 자세한 내용](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99)
서브 타입은 언제나 기반 타입으로, 즉 자식타입의 객체는 언제나 부모타입으로 교체할 수 있어야 한다는 원칙이다.

교체할 수 있다: 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 뜻-부모와 자식 클래스 사이의 행위과 일관성이 있다는 뜻이다.

그러니까... [[23-11-13 행맨, OOP, 필드, 코딩테스트|다형성]]을 얘기하는 것이다.

리스코프 치환 원칙의 핵심은 부모 클래스의 행동 규약을 자식 클래스가 위반하면 안 된다는 것이다.
행동 규약을 위반한다는 것은 자식 클래스가 오버라이딩을 할 때, 잘못되게 재정의하면 리스코프 치환 원칙을 위배할 수 있다는 의미이다.
	잘못된 오버라이딩
	- 자식 클래스가 부모 클래스의 시그니처를 멋대로 변경
	- 자식 클래스가 부모클래스의 의도와 다르게 오버라이딩
### I. 인터페이스 분리 원칙 (Interface segregation principle, ISP)
인터페이스를 필요에 맞게 잘 분리해야 한다는 설계 원칙.
클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표이다.

단, 한 번 인터페이스를 분리해 구성한 뒤 수정사항이 생겼다고 해서 인터페이스를 또 분리해서는 안 된다. 인터페이스는 한 번 구성했다면 웬만해서 변경해서는 안 된다.
### D. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
[더 자세한 내용](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-DIP-%EC%9D%98%EC%A1%B4-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99)
어떤 클래스를 참조해서 사용할 필요가 생긴다면 그 클래스를 직접 참조하지 않고 그 대상의 상위요소(추상클래스 or 인터페이스)를 참조하라는 원칙

의존 관계를 맺을 때 변화하기 쉬운/자주 변화하는(구현 클래스)것보다는, 변화하기 어려운/거의 변화가 없는 것(인터페이스)에 의존하라는 의미다.

각 클래스간의 결합도를 낮추는 것이다.
[결합도란?](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B2%B0%ED%95%A9%EB%8F%84-%EC%9D%91%EC%A7%91%EB%8F%84-%EC%9D%98%EB%AF%B8%EC%99%80-%EB%8B%A8%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC)
- 결합도: 모듈과 모듈 간의 의존 정도. 결합도가 높은 모듈들은 하나를 수정하면 다른 하나의 모듈도 수정해야 한다.
- 응집도: 한 모듈 내의 구성요소들 간 연관 정도