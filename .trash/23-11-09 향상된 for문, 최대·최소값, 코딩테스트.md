
##### 향상된 for문: 배열 안의 원소값들을 알아서 순차적으로 하나씩 꺼내준다.

우리는 기존에 초기값, 조건식, 증감식을 하나하나 적어주고서야 배열의 원소를 하나하나 꺼내는 for문을 완성할 수 있었다.
###### 기존에 하던 방식
> ==for (타입명 i=0; i<배열이름.length; i++) {
> System.out.println(배열이름[i]);
> }====
 
- 예시
 ```
 private void method2() {
		int[] arr = { 1, 2, 3, 4 };
		for(int i=0; i<arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
	} 를 하면 arr의 원소인 1 2 3 4가 나온다.
 ```

###### 향상된 for문
그러나 향상된 for문이란 것도 존재해서 보다 편하게 배열의 각 원소를 꺼내는 방법도 있다.
조건식에서 사용하기 위해 초기화한 변수(흔하게 i로 쓰는 그것.)를 반복을 돌리는 일 외에 더이상 쓸 일이 없다면, 굳이 일일이 초기..값..은...얼마...조..건..식은...얼...마... ..를 적어줄 필요가 없다.

배열 외에도, 리스트에서 사용할 수 있다고 배웠는데 리스트가 무엇인지 아직 배우진 않았다.
#배우면_리스트

> ==for (타입명 변수 : 배열이름) { 실행문 }

- 예시
 ```
 	private void method2() {
		int[] arr = { 1, 2, 3, 4 };
		for (int a : arr) {
			System.out.print(a + " ");
		}
	} 를 하면 arr의 원소인 1 2 3 4가 나온다.
	
 ```
초기값은 정해줄 필요가 없고, 반복횟수는 배열명에 넣은 배열의 길이가 될 것이다.

###### 드 모르간 법칙
조건을 설정할 때 항상 애먹는데, 드 모르간 법칙을 알면 조건설정이 보다 수월해질 거라고 하셨다...
합집합의 여집합은 여집합의 교집합이고, 교집합의 여집합은 여집합의 합집합이다.
라고만 써두면 잘 못알아듣겠지?
not A 와 not B를 더한 값은 not (Axb)와 같고,
not(A+B)는 not A와 not B를 곱한 값과 같다는 얘기다.


##### 새로 배운 내용들
###### length와 length()
배열에서 사용하는 length는 괄호 없이 썼었지만,
클래스에서 사용하는 length는 괄호를 사용해줘야 한다:  어쩌고.length() 처럼.
이게 무슨 얘기인지는 클래스를 배울 때 다시 자세하게 설명해주신다고 한다.
#배우면_클래스

###### import
```
import java.util.*;
util에 포함된 모든(*)기능을 import 하겠다는 의미다.
우리가 scan약어로 등록해놓은 템플릿에도 java.util.Scanner;가 있고,
이는 Scanner 기능을 import하여 사용하겠다는 의미다.
```
###### System.out.println(Arrays.toString(배열명));
배열을 편하게 출력할 수 있다. 굳이 for 반복문을 쓰지 않아도,
원소1, 원소2, 원소3 ...순으로 출력된다.
```
int[] arr = {1, 2, 3, 4};
System.out.println(Arrays.toString(arr));

하면 1, 2, 3, 4가 출력된다.

```
###### 배열에서 MAX값과 MIN값 찾기

-  MAX값 찾기: 매우 간단하다.
```
private void method1() {
		int[] arr = { 10, 30, 34, 54, 7 };
		int max = arr[0]; //max는 arr배열의 어떤 원소이다.
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) { // 어떤 값이 max값보다 크면
				max = arr[i]; // 그 값을 max값으로 삼자.
			}
		}
```

-  MIN값 찾기: MAX값 찾기와 같은 원리로 작동한다.
```
private void method1() {
		int[] arr = { 10, 30, 34, 54, 7 };
		int min = arr[0];
		for (int i = 0; i < arr.length; i++) {
			if (min > arr[i]) { //어떤 값이 min값보다 작다면
				min = arr[i]; //그 값을 min값으로 삼자.
			}
		}
```




##### 오늘은 코딩테스트를 계속 풀어 보았다. 다시볼만한 것들을 추렸다.
###### 두 수의 나눗셈
-  문제
 정수 num1(0 < num1 ≤ 100)과 num2(0 < num2 ≤ 100)가 매개변수로 주어질 때, 
 num1을 num2로 나눈 값에 1,000을 곱한 후
 정수 부분을 return 하도록 soltuion 함수를 완성해주세요.
```
class Solution {
    public int solution(int num1, int num2) {
      int answer = 1000*num1/num2;
        return answer;
    }
} 
```
-  선정 이유: 생각의 유연화
 내가 굳이굳이 num1/num2값을 double로 바꾸고 어쩌고 형변환에 애먹고 있을 때, 어차피 곱하기와 나누기만 있는 수식이므로 num1에 먼저 1000을 곱해 주면 굳이 형변환을 하지 않아도 됨을 알려주셨다.

###### 배열 원소의 길이
-  문제
 1 ≤ `strlist` 원소의 길이 ≤ 100
 `strlist`는 알파벳 소문자, 대문자, 특수문자로 구성되어 있습니다.
 `strlist` 각 원소의 길이를 담은 배열을 retrun하도록 solution 함수를 완성해주세요.
```
class Solution {
    public int[] solution(String[] strlist) {
        
        int[] answer = new int[strlist.length]; 
        //answer라는 배열은 strlist배열의 원소수만큼의 칸을 가질 것이다.
	        
        for (int i=0; i<answer.length; i++){ // answer라는 배열 각 칸에 값을 넣어줄건데
            String str = strlist[i]; //그 값이란 건 strlist배열의 i번째 원소, 즉 문자열이고
            answer[i] = str.length(); //그 문자열의 길이를 숫자로 변환할것이다.
        }
        return answer;
    }
}
```
-  선정 이유: 난이도
 어려웠다. 그래도 천천히 뜯어보니 할 수 있었다. 처음 주어진 배열의 원소는 문자열인데, 그 문자열의 길이를 담은 배열을 만들려면 1. 일단 그 값들을 담아줄 새 배열을 만들고, 2. 각 값을 반복문으로 넣어주면 될 것이다. 값 먼저 만들고 배열 만들면 안 돼? ... 각 값을 answer[i]라고 호명해야 하므로 answer이란 배열을 먼저 만들어주어야 한다.

###### 삼각형의 완성조건1
-  문제
 선분 세 개로 삼각형을 만든다면, 가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 한다.
 삼각형의 세 변의 길이가 담긴 배열 sides(모든 원소는 자연수, 길이는 3, 1 ≤ sides의 원소 ≤ 1,000)이 매개변수로 주어질 때, 세 변으로 삼각형을 만들 수 있다면 1, 만들 수 없다면 2를 return하도록 solution 함수를 완성해주세요.
```
import java.util.*; //util의 기능을 모두 사용할 수 있도록 import했다.
class Solution {
    public int solution(int[] sides) {
        int answer = 0;
        //가장 긴 변의 길이는 다른 두 변의 길이의 합보다 작아야 한다.
        //가장 긴 변 찾기는 1.max값 찾기, 2.정렬하기의 두가지 방법이 있다.
        //우리는 아직 max값 찾기를 배우지 않았으므로, (버블)정렬을 선택했다.
        for(int i=0; i<sides.length-1; i++){
            for(int j=0; j<sides.length-1; j++){
                if(sides[j]<sides[j+1]){
	                int temp= sides[j];
                    sides[j] = sides[j+1];
                    sides[j+1] = temp;
	            }
            }
            
            // 위의 정렬로 인덱스 0이 가장 긴 변, 1과 2가 그 나머지 변이 되었다.
            if(sides[0]<(sides[1]+sides[2])) {
                answer = 1;
            } else{
                answer = 2;
            }
    }
```

```
삼각형의 완성조건1의 다른 풀이에는 삼항연산자(이하의 코드)도 있었는데,
댓글을 보니 호불호가 굉장히 많이 갈리더라.

import java.util.Arrays;
class Solution {
    public int solution(int[] sides) {
        int answer = 0;
        Arrays.sort(sides);  //우리는 아직 sort가 뭔지 배우지 못했다.
        return sides[2] >= sides[0]+sides[1] ? 2 : 1;
    }
}

```
-  선정 이유: 생각의 유연화, max값과 min값
 문제에 조건(되면 1 안되면2)이 있으니 당연하게 if문이라고 생각했는데, 다른 풀이에는 삼항연산자도 있었고 삼항연산자는 이미 배운 내용이었다. (삼항연산자가 호불호가 많이 갈림은 차치하고도)다른 풀이가 있을 수 있음을, 그리고 이미 배운 내용 중에 있을 수 있음을 염두에 두고 생각을 다양하게 해 보자.
###### 배열의 유사도
-  문제
 두 배열이 얼마나 유사한지 확인해보려고 합니다.
 문자열 배열 s1과 s2가 주어질 때 같은 원소의 개수를 return하도록 solution 함수를 완성해주세요.
 단, 1 ≤ s1, s2의 길이 ≤ 100이고,  1 ≤ s1, s2의 원소의 길이 ≤ 10
 s1과 s2의 원소는 알파벳 소문자로만 이루어져 있습니다
 s1과 s2는 각각 중복된 원소를 갖지 않습니다.
```
class Solution {
    public int solution(String[] s1, String[] s2) {
        int answer = 0;
        
        for(String s11 : s1){ //s11은 s1배열의 각 원소값인 문자열이다.
            for(String s22: s2){ //s22 역시 s2배열의 각 원소값인 문자열이고,
                if(s11.equals(s22)) answer++; //거기서 같은 원소값이 있다면 카운트하라.
            }
        }
        return answer;
    }
}
```
-  선정 이유:  난이도, 향상된 for문
 처음에 봤을 때에는 어렵다고 생각했고 향상된 for문을 배울 수 있어서 선정했다. 그런데 향상된 for문과 그냥 for문의 차이를 비교하며 다시 읽어 보니까, 향상된 for문을 배우지 않았어도 충분히 풀 수 있는 문제였다. 문자열과 문자열의 비교니까 =가 두 개 있는 연산자가 아니라 .equals()를 사용함도 놓치지 말고 보고 가자.

###### 피자 나눠 먹기.
-  문제
 모든 피자는 7조각으로 나눈다. 피자를 나눠먹을 사람의 수 n이 주어질 때,
 모든 사람이 피자를 한 조각 이상 먹기 위해 필요한 피자의 수를 return 하는
 solution 함수를 완성해보세요.
```
class Solution {
    public int solution(int n) {
        int answer = 0;
        //사람수를 7로 나눈 몫에다가 나머지가 있으면 1을 더하고, 없으면 더하지 않는다.
        if(n%7!=0){
            answer = n/7 + 1;
        } else{
            answer = n/7;
        }
        return answer;
    }
}
```
나는 이렇게 풀었다. 틀린 풀이는 아니고, 정석적이고 평범한 풀이지만...
```
class Solution {
    public int solution(int n) {
        return (n + 6) / 7;
    }
}
```
다른 사람의 풀이 중에서 이런 코드도 있더라. 댓글에서도 많이들 놀랐다.
7로 나누었을 때 나머지는 결국 0~6일테고, 그 중 6을 더하고 나누었을 때 1이 되는 숫자는
아무것도 없으니까 이런식으로 풀 수도 있는 것이다.
-  선정 이유: 생각의 유연화
 문제가 어렵지는 않다. 정말 쉬운 문제인데, 정말 간결하게도 생각할 수 있는 것이었다.

##### 숙제가 있었는데 잘 해냈다.
###### 1. 원하는 구구단을 입력하고 출력해보기 
```
private void method1() {
		/*
		 *  원하는 구구단을 입력하고 출력해보기.
		 *  ex ) 2 -> 2단 출력
		 */
		
		System.out.println("원하는 단 수를 숫자로 입력해주세요.");
		int dan =sc.nextInt();
		for(int i=1; i<=9; i++) {
			System.out.println(dan + " * " + i + " = " + dan * i);
		}
	}
```

###### 2. 구구단을 꽉 차게 출력해보기
```
private void method2() {
		/*
		 *  구구단을 다음과 같이 출력해보기.
		 *  2 * 1 = 2	3 * 1 = 3	4 * 1 = 4	5 * 1 = 5	6 * 1 = 6	7 * 1 = 7
			2 * 2 = 4	3 * 2 = 6	4 * 2 = 8	5 * 2 = 10	6 * 2 = 12	7 * 2 = 14
			2 * 3 = 6	3 * 3 = 9	4 * 3 = 12	5 * 3 = 15	6 * 3 = 18	7 * 3 = 21
			2 * 4 = 8	3 * 4 = 12	4 * 4 = 16	5 * 4 = 20	6 * 4 = 24	7 * 4 = 28
			2 * 5 = 10	3 * 5 = 15	4 * 5 = 20	5 * 5 = 25	6 * 5 = 30	7 * 5 = 35
			2 * 6 = 12	3 * 6 = 18	4 * 6 = 24	5 * 6 = 30	6 * 6 = 36	7 * 6 = 42
			2 * 7 = 14	3 * 7 = 21	4 * 7 = 28	5 * 7 = 35	6 * 7 = 42	7 * 7 = 49
			2 * 8 = 16	3 * 8 = 24	4 * 8 = 32	5 * 8 = 40	6 * 8 = 48	7 * 8 = 56
			2 * 9 = 18	3 * 9 = 27	4 * 9 = 36	5 * 9 = 45	6 * 9 = 54	7 * 9 = 63
			(원래 9단까지 있어야 하는데, 옵시디언에 백업한다고 8단 이후로 잘랐다.)
		 */
		int i=0;
		int j=0;
		for(i=1; i<10; i++) { j * i형태로 나올 건데, i가 변할 때마다 다른 줄이 된다.
			System.out.println();
			//놓친 내용: 가로줄은 (2~9단)8개밖에 안되니까 2부터 시작해야 한다.
			for(j=2; j<10; j++) {
				// j가 단이다. 단 수가 늘어나면 다음 줄이 아니라 오른쪽으로 가니까
				// j를 반복하는 for문에서 print와 \t를 넣어줘야 한다.
				System.out.print(j + " * " + i + " = " + i*j + "\t");
			}
		}
	}

```

###### 3. 입력받은 단을 제외하고 2번처럼 출력하기
```
import java.util.Scanner;
private void method3() {
		/*
		 *  구구단 중 입력한 숫자를 제외하고 출력 
		 *  다음과  같이 출력해보기.
		 *  ex) 4 -> 
		 *  2 * 1 = 2	3 * 1 = 3		5 * 1 = 5	6 * 1 = 6	7 * 1 = 7
			2 * 2 = 4	3 * 2 = 6		5 * 2 = 10	6 * 2 = 12	7 * 2 = 14
			2 * 3 = 6	3 * 3 = 9		5 * 3 = 15	6 * 3 = 18	7 * 3 = 21
			2 * 4 = 8	3 * 4 = 12		5 * 4 = 20	6 * 4 = 24	7 * 4 = 28
			2 * 5 = 10	3 * 5 = 15		5 * 5 = 25	6 * 5 = 30	7 * 5 = 35
			2 * 6 = 12	3 * 6 = 18		5 * 6 = 30	6 * 6 = 36	7 * 6 = 42
			2 * 7 = 14	3 * 7 = 21		5 * 7 = 35	6 * 7 = 42	7 * 7 = 49
			2 * 8 = 16	3 * 8 = 24		5 * 8 = 40	6 * 8 = 48	7 * 8 = 56
			2 * 9 = 18	3 * 9 = 27		5 * 9 = 45	6 * 9 = 54	7 * 9 = 63
			(역시 원래 9단까지 있는 건데 옵시디언 백업 문제로 잘랐다...)
		 */
		
		System.out.println("제외할 단 수를 입력해주세요.");
		//이걸 썼다는 건 사실 저어어어위에 import java.util.Scanner;가 있단 얘기일 테다.
		int anham = sc.nextInt();  
		int i=0;
		int j=0;
		
		for(i=1; i<10; i++) {
			
			System.out.println();
			// j의 for 반복문 설정까지는 위와 동일하지만,
			for(j=2; j<10; j++) { 
				
				//입력받은 anham 단이 되면 출력으로 내려가지 않고 다음 반복조건으로 넘어간다
				if(j==anham) {
					continue;
				}
				
				System.out.print(j + " * " + i + " = " + i*j + "\t");
			} //오늘의 숙제는 수업시간 안에 내 힘으로 해냈다!
		}
	}

```


